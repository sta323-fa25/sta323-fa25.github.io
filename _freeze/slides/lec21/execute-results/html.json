{
  "hash": "42641f3719a8e6d503a54255bb41d1ba",
  "result": {
    "markdown": "---\ntitle: \"Covariance and Principal Components\"\nauthor: \"Dr. Alexander Fisher\"\nexecute:\n  warning: true\nformat: \n    revealjs:\n      smaller: true\n---\n\n\n# Announcements\n\nReminder:\n\n-   Final project presentations during lab Tuesday, April 25.\n\n# Covariance\n\n## Covariance and correlation\n\nEmpirical covariance between two variables\n\n\n$$\ncov(X,Y) = \\frac{1}{n-1} \\sum_{i = 1}^{n} (x_i - \\bar{x})(y_i - \\bar{y})\n$$\n\n\nEmpirical correlation between two variables,\n\n\n$$\n\\rho_{XY} = \\frac{cov(X,Y)}{\\sigma_X \\sigma_Y}\n$$\n\n\nwhere $\\sigma_X$ and $\\sigma_Y$ are the standard deviation of X and Y respectively.\n\n. . . \n\nNotice that the correlation matrix is just the covariance matrix of the standardized data.\n\nEasy to see from definition of covariance\n\n\n$$\ncov(X, Y) = \\mathbb{E} [(X - \\mathbb{E}[X] ) (Y - \\mathbb{E}[Y])]\n$$\n\n\n## `cov`  and `cor` demo\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 2, 3, 4, 5)\ny = c(0.5, 3, 2.2, 5, 5.5)\n```\n:::\n\n\n::: panel-tabset\n\n## demo \n\n::: {.cell}\n\n```{.r .cell-code}\n# covariance\ncov(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n# correlation\ncor(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.9243906\n```\n:::\n\n```{.r .cell-code}\n# covariance of standardized variables\nxs = (x - mean(x)) / sd(x)# x-standardized\nys = (y - mean(y)) / sd(y)# y-standardized\n\ncov(xs, ys)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.9243906\n```\n:::\n:::\n\n\n## covariance matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd = data.frame(x = x, y = y)\ncov(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    x     y\nx 2.5 3.000\ny 3.0 4.213\n```\n:::\n:::\n\n\n\n## correlation matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd = data.frame(x = x, y = y)\ncor(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          x         y\nx 1.0000000 0.9243906\ny 0.9243906 1.0000000\n```\n:::\n:::\n\n\n\n:::\n\n\n## Data\n\n\n::: {.cell}\n\n:::\n\n\n\n`Hawks` is a subset of a data set by the same name in the `Stat2Data` package. Today we will focus on the following measurements of 891 hawks:\n\n- `Species`: CH = cooper's, RT = red-tailed, SS = sharp-shinned\n- `Weight`: body weight in grams\n- `Wing`: length in mm of primary wing feather from tip to wrist it attaches to\n- `Culmen`: length in mm of the upper bill from the tip to where it bumps into the fleshy part of the bird\n- `Hallux`: length in mm of the killing talon\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHawks = read_csv(\"https://sta101-fa22.netlify.app/static/appex/data/Hawks.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(Hawks)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 891\nColumns: 5\n$ Species <chr> \"RT\", \"RT\", \"CH\", \"SS\", \"RT\", \"RT\", \"RT\", \"RT\", \"RT\", \"RT\", \"R…\n$ Weight  <dbl> 920, 990, 470, 170, 1090, 960, 855, 1210, 1120, 1010, 1010, 11…\n$ Wing    <dbl> 385, 381, 265, 205, 412, 370, 375, 412, 405, 393, 371, 390, 41…\n$ Culmen  <dbl> 25.7, 26.7, 18.7, 12.5, 28.5, 25.3, 27.2, 29.3, 26.0, 26.3, 25…\n$ Hallux  <dbl> 30.1, 31.3, 23.5, 14.3, 32.2, 30.1, 30.0, 31.3, 30.2, 30.8, 29…\n```\n:::\n:::\n\n\n\n## Visualizing covariance\n\nLet's look at hawk weight and wing length.\n\n::: panel-tabset\n\n## Data\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lec21_files/figure-revealjs/unnamed-chunk-14-1.png){width=960}\n:::\n:::\n\n\n<!-- ## Standardized data -->\n\n\n::: {.cell}\n\n:::\n\n\n## Covariance matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Covariance matrix\ncovMatrix1 = Hawks %>%\n  select(Weight, Wing) %>%\n  cov()\n\ncovMatrix1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Weight      Wing\nWeight 214310.57 41247.975\nWing    41247.97  9085.273\n```\n:::\n:::\n\n\n\n## Visualize covariance\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lec21_files/figure-revealjs/unnamed-chunk-20-1.png){width=960}\n:::\n:::\n\n\n:::\n\n## The mathematics of the covariance ellipsoid\n\nCovariance matrix $\\Sigma$ collects variances and covariances together,\n\n\n$$\n\\Sigma = \\begin{pmatrix}\\sigma_x^2 & \\sigma_{xy}^2\\\\\\ \\sigma_{xy}^2 & \\sigma_y^2\\end{pmatrix}\n$$\n\nHow can we visualize the covariance matrix above?\n\nThe \"matrix inverse\" helps. The inverse of $\\Sigma$ is denoted $\\Sigma^{-1}$. The property of the inverse is:\n\n\n$$\n\\Sigma^{-1} \\Sigma = \\begin{pmatrix}1 & 0\\\\\\ 0 & 1 \\end{pmatrix}\n$$\n\n\nWe can visualize the covariance matrix by forming the quadratic,\n\n\n\n$$\nz^T \\Sigma^{-1} z = c^2,\n$$\n\n\nwhere $z = (x, y)$ and $\\Sigma^{-1} = \\begin{pmatrix}s_x^2 & s_{xy}^2\\\\\\ s_{xy}^2 & s_y^2\\end{pmatrix}$. Where have we seen this before? Hint: see [multivariate normal](https://en.wikipedia.org/wiki/Multivariate_normal_distribution)\n\n## Notice the linear equations\n\nBy multiplying out the product in scalar notation\n\n\n$$\n\\begin{pmatrix} x & y\\end{pmatrix} \n\\begin{pmatrix}s_x^2 & s_{xy}^2\\\\\\ s_{xy}^2 & s_y^2\\end{pmatrix}\n\\begin{pmatrix} x\\\\\\ y \\end{pmatrix}\n= c^2\n$$\n\n$$\n(x s_x^2 + y s_{xy}^2 \\ \\ \\ \\ x s_{xy}^2 + y s_y^2) \\begin{pmatrix} x\\\\\\ y \\end{pmatrix} = c^2\n$$\n\n$$\nx^2 s_x^2 + 2x y \\cdot s_{xy}^2 + y^2 s_y^2 = c^2\n$$\n\nThis is the equation of an ellipse where our choice of $c$ defines the size of the ellipse.\n\n## Connection: MVN\n\n::: panel-tabset \n\n## Simulate data\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mvtnorm)\nset.seed(1)\n\nmu = c(5, 10)\nsigma = matrix(data = c(2, .8, .8, 1), ncol = 2, nrow = 2)\n\npoints = rmvnorm(n = 500,\n        mean = mu,\n        sigma = sigma)\n\nd = tibble(x = points[,1],\n           y = points[,2]) \n\nd %>%\n  head(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 2\n      x     y\n  <dbl> <dbl>\n1  4.20  9.96\n2  4.41 11.2 \n3  5.17  9.34\n4  5.92 10.9 \n5  5.68  9.91\n```\n:::\n:::\n\n\n\n## plot\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lec21_files/figure-revealjs/unnamed-chunk-24-1.png){width=960}\n:::\n:::\n\n\n## code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nellipsePoints = data.frame(ellipse(sigma))\nellipsePoints[\"x\"] = ellipsePoints[\"x\"] + mu[1]\nellipsePoints[\"y\"] = ellipsePoints[\"y\"] + mu[2]\n\nd %>%\n  ggplot(aes(x = x, y = y)) + \n  geom_point() +\n  theme_bw() +\n  geom_path(aes(x = x, y = y), data = ellipsePoints,\n             color = 'steelblue')\n```\n:::\n\n\nWhat $c$ was used? \n\n`?ellipse` has the answer... $c^2 \\approx 6$ for 2-d variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqchisq(0.95, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.991465\n```\n:::\n:::\n\n\n:::\n\n## Exercise\n\n::: panel-tabset\n\n## prompt\nPerform a sanity check. Plot the ellipse manually using the formula from a previous slide and using $c^2$ = 6. To avoid having to re-center on the centroid, you can standardize the data.\n\n\n## 1 - standardize\n\n::: {.cell}\n\n```{.r .cell-code}\nHawks2 = Hawks %>%\n  mutate(sWeight = (Weight - mean(Weight)) / sd(Weight),\n         sWing = (Wing - mean(Wing)) / sd(Wing))\n\ncovMatrix2 = Hawks2 %>%\n  select(sWeight, sWing) %>%\n  cov()\n\ncovMatrix2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          sWeight     sWing\nsWeight 1.0000000 0.9347852\nsWing   0.9347852 1.0000000\n```\n:::\n:::\n\n\nNext, get $\\Sigma^{-1}$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsolve(covMatrix2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          sWeight     sWing\nsWeight  7.925401 -7.408548\nsWing   -7.408548  7.925401\n```\n:::\n:::\n\n\n## 2 - solve quadratic\n\nNext, we manually solve the quadratic equation using the quadratic formula (set $c^2 = 6$)\n\n\n$$\nx^2 s_x^2 + 2x y \\cdot s_{xy}^2 + y^2 s_y^2 = 6\n$$\n\n::: {.cell}\n\n```{.r .cell-code}\nsx = 7.925401\nsxy = -7.408548\nsy = 7.925401\n\nf = function(x) {\n  A = sy \n  B = 2 * x * sxy\n  C = (x * x * sx) - 6\n\n  (-B + sqrt(B^2 - (4* A * C))) / (2 * A)\n}\n\nf2 = function(x) {\n  A = sy \n  B = 2 * x * sxy\n  C = (x * x * sx) - 6\n\n  (-B - sqrt(B^2 - (4* A * C))) / (2 * A)\n}\n```\n:::\n\n\n\n## 3 - plot comparison\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lec21_files/figure-revealjs/unnamed-chunk-36-1.png){width=960}\n:::\n:::\n\n\n\n## 4 - plot code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n# Grab the points (x,y) that satisfy the equation\nellipsePoints = data.frame(ellipse(covMatrix2))\nm1 = data.frame(x = seq(-3, 3, by = 0.001)) %>%\n  mutate(y = f(x)) %>%\n  filter(!is.nan(y))\n\nm2 = m1 %>%\n  mutate(y = f2(x)) %>%\n  filter(!is.nan(y))\n\nmanualEllipsePoints = rbind(m1, m2) %>%\n  slice_sample(n = 200)\n\nHawks2 %>%\n  ggplot(aes(x = sWeight, y = sWing)) +\n  geom_point() +\n  theme_bw() +\n  geom_path(aes(x = sWeight, y = sWing,\n                 color = \"ellipse()\"), data = ellipsePoints) +\n  geom_point(aes(x = x, y = y, color = \"manual\"), \n            data = manualEllipsePoints, alpha = 1,\n            size = 1,) +\n  labs(title = \"Standardized wing vs weight\")\n```\n:::\n\n\n:::\n\n# Principal components\n\n## Principal components\n\nThe axes of the ellipse provide the most informative directions to measure the data. In $n$-dimensions, where we have a $n$-dimensional ellipsoid, it can be useful to look at $p<n$ axes. The largest axis is called the \"first\" principal component. The second largest axis is called the \"second\" principal component and so on.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lec21_files/figure-revealjs/unnamed-chunk-40-1.png){width=960}\n:::\n:::\n\n\n\n\n\n\n## Compute principal components\n\n::: panel-tabset\n\n## compute\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get PCs\nHawks %>%\n  select(Weight, Wing) %>%\n  prcomp(scale = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStandard deviations (1, .., p=2):\n[1] 1.3909656 0.2553718\n\nRotation (n x k) = (2 x 2):\n              PC1        PC2\nWeight -0.7071068  0.7071068\nWing   -0.7071068 -0.7071068\n```\n:::\n:::\n\n\n## plot\n\n::: {.cell}\n::: {.cell-output-display}\n![](lec21_files/figure-revealjs/unnamed-chunk-44-1.png){width=960}\n:::\n:::\n\n\n## code\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# make plot\nHawks %>%\n    mutate(pc1 = (0.7071068 * Weight) + (0.7071068 * Wing)) %>%\n    ggplot(aes(x = pc1, y = 0, color = Species)) + \n    geom_point()\n```\n:::\n\n:::\n\n## PCA summary\n\n- \"Principal components\" refers to the ranked **orthogonal** axes of the ellipsoid generated from the covariance matrix of the data.\n\n- The components are ranked largest to smallest.\n\n- PCA is a dimension-reduction technique. Often we examine the first 1 to 3 principal components to create visualizations of high-dimensional data.\n\n- What we gain in simplicity we often lose in interpretability. The 'dimensions' that capture the maximum variability of the data are created from linear combinations of the variables. These linear combinations are often difficult to interpret / motivate.\n\n## Higher dimensional example\n\n::: panel-tabset\n\n## plot\n\n::: {.cell}\n::: {.cell-output-display}\n![](lec21_files/figure-revealjs/unnamed-chunk-48-1.png){width=960}\n:::\n:::\n\n\n## code\n\n::: {.cell}\n\n```{.r .cell-code}\nhpc = Hawks %>%\n  select(Weight, Wing, Culmen, Hallux) %>%\n  prcomp(scale = FALSE) %>%\n  .[\"rotation\"] %>%\n  as.data.frame() %>%\n  setNames(., paste0(\"PC\", seq(4)))\n\n# explicitly mapping\nHawks %>%\n  mutate(PC1 = (hpc$PC1[1] * Weight) + \n           (hpc$PC1[2] * Wing) + \n           (hpc$PC1[3] * Culmen) + \n           (hpc$PC1[4] * Hallux),\n         PC2 = (hpc$PC2[1] * Weight) + \n           (hpc$PC2[2] * Wing) + \n           (hpc$PC2[3] * Culmen) + \n           (hpc$PC2[4] * Hallux)) %>%\n  ggplot(aes(x = PC1, y = PC2, color = Species)) +\n  geom_point()\n```\n:::\n\n:::\n\n\n## Further reading\n\nThis lecture is inspired by \n\n> [Friendly, Michael, Georges Monette, and John Fox. \"Elliptical insights: understanding statistical methods through elliptical geometry.\" (2013): 1-39.](https://arxiv.org/pdf/1302.4881.pdf)\n\nFor further reading on principal component analysis in action, see\n\n> [Novembre, John, et al. \"Genes mirror geography within Europe.\" Nature 456.7218 (2008): 98-101.](https://www.nature.com/articles/nature07331) \n\nand [an associated news article](https://www.nationalgeographic.com/science/article/european-genes-mirror-european-geography) discussing the work.\n\n",
    "supporting": [
      "lec21_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    function fireSlideChanged(previousSlide, currentSlide) {\n\n      // dispatch for htmlwidgets\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for reveal\n    if (window.Reveal) {\n      window.Reveal.addEventListener(\"slidechanged\", function(event) {\n        fireSlideChanged(event.previousSlide, event.currentSlide);\n      });\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}