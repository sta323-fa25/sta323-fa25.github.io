{
  "hash": "d156247bf8057e52ba06e86ac5c46c74",
  "result": {
    "markdown": "---\ntitle: \"Cryptanalysis\"\nauthor: \"Dr. Alexander Fisher\"\nexecute:\n  warning: true\nformat: \n    revealjs:\n      smaller: true\n---\n\n\n# Announcements\n\nReminder:\n\n-   Final project report due today 5pm.\n-   $>80$% course evaluations = +1 pt extra credit to project\n\n# Cryptanalysis\n\n## Basic terminology\n\n-   cryptography: making secret messages (encryption)\n    -   substitution\n    -   transposition\n-   cryptanalysis: breaking secret messages (decryption)\n-   cryptology: the study of cryptography and cryptanalysis\n\n. . .\n\n-   plain text: the actual message\n-   cipher text: the encrypted message\n-   key: information to encode (or decode) cryptographic key\n  - symmetric (same key for encryption and decryption)\n  - asymmetric (different key to encrypt and decrypt)\n\n## Motivation\n\n![](https://sta101.github.io/static/img/prisonLetter.png){width=\"75%\"}\n\n[Diaconis, Persi. \"The markov chain monte carlo revolution.\" Bulletin of the American Mathematical Society 46.2 (2009): 179-205.](https://math.uchicago.edu/~shmuel/Network-course-readings/MCMCRev.pdf)\n\n## Substitution cipher\n\n-   Idea: each character of plaintext is substitude with another character\n\n. . .\n\nExample:\n\n![](images/ex-rot13.png){fig-align=\"center\" width=\"600\"}\n\nFrom <https://en.wikipedia.org/wiki/Substitution_cipher>\n\n## Exercise\n\n- Given the message below is encoded with a substitution cipher, how many possible keys are there?\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsecret_message\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"REART COSFRA COS AU DR UT EUA AU DR ACOA BL ACR MIRLABUE ZCRACRT ABL EUDFRT BE ACR SBEV AU LIPPRT ACR LFBENL OEV OTTUZL UP UIATONRUIL PUTAIER UT AU AOQR OTSL ONOBELA O LRO UP ATUIDFRL OEV DK UGGULBEN REV ACRS\"\n```\n:::\n:::\n\n\n- Trying every possible key is known as a \"brute force\" approach. Chat with your neighbor and develop a strategy better than the brute force approach.\n\n- Continue the exercise by downloading the file below\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndownload.file(url = \"https://sta323-sp23.github.io/scripts/cryptanalysis.qmd\",\n              destfile = \"cryptanalysis.qmd\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    function fireSlideChanged(previousSlide, currentSlide) {\n\n      // dispatch for htmlwidgets\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for reveal\n    if (window.Reveal) {\n      window.Reveal.addEventListener(\"slidechanged\", function(event) {\n        fireSlideChanged(event.previousSlide, event.currentSlide);\n      });\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}