{
  "hash": "354dedc11d379a4aecc96c7d5e6696e9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Databases, SQL and dplyr\"\nauthor: \"Dr. Alexander Fisher\"\nexecute:\n  warning: true\nformat: \n    revealjs:\n      smaller: true\n---\n\n\n\n## Numbers every programmer should know\n\n| Task                                | Timing (ns)       | Timing (μs)       |\n|-------------------------------------|-------------------|-------------------|\n| L1 cache reference                  | 0.5               | 0.0005            |\n| L2 cache reference                  | 7                 | 0.007             |\n| Main memory reference               | 100               | 0.1               |\n| Random seek SSD                     | 150,000           | 150               |\n| Read 1 MB sequentially from memory  | 250,000           | 250               |\n| Read 1 MB sequentially from SSD     | 1,000,000         | 1,000             |\n| Disk seek                           | 10,000,000        | 10,000            |  \n| Read 1 MB sequentially from disk    | 20,000,000        | 20,000            |\n| Send packet CA->Netherlands->CA     | 150,000,000       | 150,000           |\n\n\n\n\n\n\n\n\n::: {.aside}\nFrom [jboner/latency.txt](https://gist.github.com/jboner/2841832) & [sirupsen/napkin-math](https://github.com/sirupsen/napkin-math) <br/>\nJeff Dean's original [talk](http://static.googleusercontent.com/media/research.google.com/en/us/people/jeff/stanford-295-talk.pdf) \n:::\n\n\n## Implications for big data\n\nLets imagine we have a *10 GB* flat data file and that we want to select certain rows based on a particular criteria. This requires a sequential read across the entire data set.\n\n\n| File Location    | Performance                        | Time        |\n|:-----------------|:-----------------------------------|:------------|\n| in memory        | $10~GB \\times (250~\\mu s / 1~MB)$  | 2.5 seconds |\n| on disk (SSD)    | $10~GB \\times (1~ms / 1~MB)$       | 10 seconds  |\n| on disk (HD)     | $10~GB \\times (20~ms / 1~MB)$      | 200 seconds |\n\n<br/>\n\nThis is just for *reading* sequential data, if we make any modifications (*writing*) or the data is fragmented things are much worse. \n\n\n## Blocks\n\n<br/>\n\n#### Cost:\n::: {.center}\n Disk << SSD <<< Memory\n:::\n\n\n#### Speed:\n::: {.center}\nDisk <<< SSD << Memory\n:::\n\n<br/>\n\n::: {.fragment}\nSo usually possible to grow our disk storage to accommodate our data. However, memory is usually the limiting resource, and if we can't fit everything into memory?\n:::\n\n<p/>\n\n::: {.fragment}\nCreate *blocks* - group related data (i.e. rows) and read in multiple rows at a time. Optimal size will depend on the task and the properties of the disk.\n:::\n\n\n## Linear vs Binary Search\n\nEven with blocks, any kind of querying / subsetting of rows requires a linear search, which requires $\\mathcal{O}(N)$ reads.\n\n. . .\n\n<br/>\n\nWe can do better if we are careful about how we structure our data, specifically sorting some (or all) of the columns. \n\n* Sorting is expensive, $\\mathcal{O}(N \\log N)$, but it only needs to be done once. \n\n* After sorting, we can use a binary search for any subsetting tasks, $\\mathcal{O}(\\log N)$\n\n* In a databases these \"sorted\" columns are refered to as *indexes*.\n\n* Indexes require additional storage, but usually small enough to be kept in memory even if blocks need to stay on disk.\n\n\n# Databases\n\n## R & databases - the DBI package\n\nLow level package for interfacing R with Database management systems (DBMS) that provides a common interface to achieve the following functionality:\n\n* connect/disconnect from DB\n* create and execute statements in the DB\n* extract results/output from statements\n* error/exception handling\n* information (meta-data) from database objects\n* transaction management (optional)\n\n\n::: {.aside}\nSee [r-dbi.org](https://www.r-dbi.org/) for more details\n:::\n\n\n## DBI Backends\n\nDBI is a specification, not an implementation, and there are a number of packages that implement the DBI specification for different database systems. [Backends for R-DBI](https://r-dbi.org/backends/) lists all available backends, but some notable ones include:\n\n* `RPostgres`\n\n* `RMariaDB`\n\n* `RSQLite`\n\n* `odbc`\n\n* `bigrquery`\n\n* `duckdb`\n\n* `sparklyr`\n\n\n## RSQLite\n\nProvides the implementation necessary to use DBI to interface with an SQLite database.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(RSQLite)\n```\n:::\n\n\n\n\nthis package also loads the necessary DBI functions as well (via re-exporting).\n\n. . .\n\nOnce loaded we can create a connection to our database,\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon = dbConnect(RSQLite::SQLite(), \":memory:\")\n# :memory: creates a temporary, in-memory SQLite data base\nstr(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFormal class 'SQLiteConnection' [package \"RSQLite\"] with 8 slots\n  ..@ ptr                :<externalptr> \n  ..@ dbname             : chr \":memory:\"\n  ..@ loadable.extensions: logi TRUE\n  ..@ flags              : int 70\n  ..@ vfs                : chr \"\"\n  ..@ ref                :<environment: 0x107abb778> \n  ..@ bigint             : chr \"integer64\"\n  ..@ extended_types     : logi FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n## Example Table\n \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemployees = tibble(\n  name   = c(\"Alice\",\"Bob\",\"Carol\",\"Dave\",\"Eve\",\"Frank\"),\n  email  = c(\"alice@company.com\", \"bob@company.com\",\n             \"carol@company.com\", \"dave@company.com\",\n             \"eve@company.com\",   \"frank@comany.com\"),\n  salary = c(52000, 40000, 30000, 33000, 44000, 37000),\n  dept   = c(\"Accounting\", \"Accounting\",\"Sales\",\n             \"Accounting\",\"Sales\",\"Sales\"),\n)\n```\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndbWriteTable(con, name = \"employees\", value = employees)\ndbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"employees\"\n```\n\n\n:::\n:::\n\n\n\n\n\n## Removing Tables\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbWriteTable(con, \"employs\", employees)\ndbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"employees\" \"employs\"  \n```\n\n\n:::\n:::\n\n\n\n\n<p/>\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbRemoveTable(con,\"employs\")\ndbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"employees\"\n```\n\n\n:::\n:::\n\n\n\n\n\n## Querying Tables\n\nDatabases queries are transactional (see [ACID](https://en.wikipedia.org/wiki/ACID)) and are broken up into 3 steps:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(res = dbSendQuery(con, \"SELECT * FROM employees\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQLiteResult>\n  SQL  SELECT * FROM employees\n  ROWS Fetched: 0 [incomplete]\n       Changed: 0\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbFetch(res)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   name             email salary       dept\n1 Alice alice@company.com  52000 Accounting\n2   Bob   bob@company.com  40000 Accounting\n3 Carol carol@company.com  30000      Sales\n4  Dave  dave@company.com  33000 Accounting\n5   Eve   eve@company.com  44000      Sales\n6 Frank  frank@comany.com  37000      Sales\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbClearResult(res)\n```\n:::\n\n\n\n\n\n## For convenience\n\nThere is also `dbGetQuery()` which combines all three steps,\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(res = dbGetQuery(con, \"SELECT * FROM employees\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   name             email salary       dept\n1 Alice alice@company.com  52000 Accounting\n2   Bob   bob@company.com  40000 Accounting\n3 Carol carol@company.com  30000      Sales\n4  Dave  dave@company.com  33000 Accounting\n5   Eve   eve@company.com  44000      Sales\n6 Frank  frank@comany.com  37000      Sales\n```\n\n\n:::\n:::\n\n\n\n\n## Creating tables\n\n`dbCreateTable()` will create a new table with a schema based on an existing data.frame / tibble, but it does not populate that table with data.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbCreateTable(con, \"iris\", iris)\n(res = dbGetQuery(con, \"select * from iris\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Sepal.Length Sepal.Width  Petal.Length Petal.Width  Species     \n<0 rows> (or 0-length row.names)\n```\n\n\n:::\n:::\n\n\n\n\n\n## Adding to tables\n\nData can be added to an existing table via `dbAppendTable()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbAppendTable(con, name = \"iris\", value = iris)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Factors converted to character\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 150\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbGetQuery(con, \"select * from iris\") |> \n  as_tibble()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <chr>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ℹ 140 more rows\n```\n\n\n:::\n:::\n\n\n\n\n## Recap \n\nWe've connected to a database. We can view the tables within the database: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"employees\" \"iris\"     \n```\n\n\n:::\n:::\n\n\n\nWe can even save the connnection to a specific table within the databse:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemp <- tbl(con, \"employees\")\n```\n:::\n\n\n\n\n\n## filter() using WHERE\n\nWe can run SQL directly:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- \n  dbGetQuery(con, \"SELECT * FROM employees WHERE salary < 40000\")\n\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   name             email salary       dept\n1 Carol carol@company.com  30000      Sales\n2  Dave  dave@company.com  33000 Accounting\n3 Frank  frank@comany.com  37000      Sales\n```\n\n\n:::\n:::\n\n\n\n\n## group_by() and summarize() via GROUP BY\n\nWe can create groups for the purpose of summarizing using `GROUP BY`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- \n  dbGetQuery(con, \"SELECT dept, COUNT(*) AS n FROM employees GROUP BY dept\")\n\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        dept n\n1 Accounting 3\n2      Sales 3\n```\n\n\n:::\n:::\n\n\n\nThe \"AS\" keyword in SQL is essentially a way to rename a column or table in the result. From a dplyr standpoint, it's very similar to how we use `mutate()` or `summarize()`.\n\n## head() using LIMIT \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbGetQuery(con, \"SELECT * FROM employees\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   name             email salary       dept\n1 Alice alice@company.com  52000 Accounting\n2   Bob   bob@company.com  40000 Accounting\n3 Carol carol@company.com  30000      Sales\n4  Dave  dave@company.com  33000 Accounting\n5   Eve   eve@company.com  44000      Sales\n6 Frank  frank@comany.com  37000      Sales\n```\n\n\n:::\n:::\n\n\n\n\n## Exercise \n\nUsing SQL syntax, \n\n::: panel-tabset\n## Exercise\n1. compute the total costs in payroll for this company.\n\n2. the average salary within each department\n\n## Solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntotal_salary <- dbGetQuery(con, \n\"SELECT SUM(salary) AS total_salary\n    FROM employees\")\ntotal_salary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  total_salary\n1       236000\n```\n\n\n:::\n\n```{.r .cell-code}\navg_salary_by_dept <- dbGetQuery(con, \n\"SELECT dept,\n           AVG(salary) AS avg_salary,\n           SUM(salary) AS total_salary\n    FROM employees\n    GROUP BY dept\")\navg_salary_by_dept\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        dept avg_salary total_salary\n1 Accounting   41666.67       125000\n2      Sales   37000.00       111000\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n\n## Closing the connection\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQLiteConnection>\n  Path: :memory:\n  Extensions: TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ndbDisconnect(con)\n```\n:::\n\n\n\n\n<p/>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQLiteConnection>\n  DISCONNECTED\n```\n\n\n:::\n:::\n\n\n\n\n\n# dplyr & databases\n\n\n## Creating a database \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndb = DBI::dbConnect(RSQLite::SQLite(), \"flights.sqlite\")\n( flight_tbl = dplyr::copy_to(\n    db, nycflights13::flights, name = \"flights\", temporary = FALSE) )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   table<`flights`> [?? x 19]\n# Database: sqlite 3.50.4 [flights.sqlite]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\n## What have we created?\n\nAll of this data now lives in the database on the *filesystem* not in *memory*,\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npryr::object_size(db)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2.46 kB\n```\n\n\n:::\n\n```{.r .cell-code}\npryr::object_size(flight_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n6.50 kB\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npryr::object_size(nycflights13::flights)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n40.65 MB\n```\n\n\n:::\n:::\n\n\n\n\n## File size\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::dir_info(glob = \"*.sqlite\") |>\n  select(path, type, size)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  path           type         size\n  <fs::path>     <fct> <fs::bytes>\n1 flights.sqlite file        21.1M\n```\n\n\n:::\n:::\n\n\n\n\n\n## What is `flight_tbl`?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(nycflights13::flights)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(flight_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_SQLiteConnection\" \"tbl_dbi\"              \"tbl_sql\"             \n[4] \"tbl_lazy\"             \"tbl\"                 \n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n::: {.small}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(flight_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ src       :List of 2\n  ..$ con  :Formal class 'SQLiteConnection' [package \"RSQLite\"] with 8 slots\n  .. .. ..@ ptr                :<externalptr> \n  .. .. ..@ dbname             : chr \"flights.sqlite\"\n  .. .. ..@ loadable.extensions: logi TRUE\n  .. .. ..@ flags              : int 70\n  .. .. ..@ vfs                : chr \"\"\n  .. .. ..@ ref                :<environment: 0x1105c72e0> \n  .. .. ..@ bigint             : chr \"integer64\"\n  .. .. ..@ extended_types     : logi FALSE\n  ..$ disco: NULL\n  ..- attr(*, \"class\")= chr [1:4] \"src_SQLiteConnection\" \"src_dbi\" \"src_sql\" \"src\"\n $ lazy_query:List of 5\n  ..$ x         : 'dbplyr_table_path' chr \"`flights`\"\n  ..$ vars      : chr [1:19] \"year\" \"month\" \"day\" \"dep_time\" ...\n  ..$ group_vars: chr(0) \n  ..$ order_vars: NULL\n  ..$ frame     : NULL\n  ..- attr(*, \"class\")= chr [1:3] \"lazy_base_remote_query\" \"lazy_base_query\" \"lazy_query\"\n - attr(*, \"class\")= chr [1:5] \"tbl_SQLiteConnection\" \"tbl_dbi\" \"tbl_sql\" \"tbl_lazy\" ...\n```\n\n\n:::\n:::\n\n\n:::\n\n\n## Accessing existing tables\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::tbl(db, \"flights\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   table<`flights`> [?? x 19]\n# Database: sqlite 3.50.4 [flights.sqlite]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\n## Using dplyr with sqlite \n\n:::: {.columns .small}\n::: {.column width='50%'}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(oct_21 = flight_tbl |>\n   filter(month == 10, day == 21) |>\n   select(origin, dest, tailnum)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 3]\n# Database: sqlite 3.50.4 [flights.sqlite]\n   origin dest  tailnum\n   <chr>  <chr> <chr>  \n 1 EWR    CLT   N152UW \n 2 EWR    IAH   N535UA \n 3 JFK    MIA   N5BSAA \n 4 JFK    SJU   N531JB \n 5 JFK    BQN   N827JB \n 6 LGA    IAH   N15710 \n 7 JFK    IAD   N825AS \n 8 EWR    TPA   N802UA \n 9 LGA    ATL   N996DL \n10 JFK    FLL   N627JB \n# ℹ more rows\n```\n\n\n:::\n:::\n\n\n:::\n::: {.column width='50%' .fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::collect(oct_21)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 991 × 3\n   origin dest  tailnum\n   <chr>  <chr> <chr>  \n 1 EWR    CLT   N152UW \n 2 EWR    IAH   N535UA \n 3 JFK    MIA   N5BSAA \n 4 JFK    SJU   N531JB \n 5 JFK    BQN   N827JB \n 6 LGA    IAH   N15710 \n 7 JFK    IAD   N825AS \n 8 EWR    TPA   N802UA \n 9 LGA    ATL   N996DL \n10 JFK    FLL   N627JB \n# ℹ 981 more rows\n```\n\n\n:::\n:::\n\n\n:::\n::::\n\n\n\n## Laziness\n\ndplyr / dbplyr uses lazy evaluation as much as possible, particularly when working with non-local backends.\n\n* When building a query, we don't want the entire table, often we want just enough to check if our query is working / makes sense.\n\n* Since we would prefer to run one complex query over many simple queries, laziness allows for verbs to be strung together.\n\n* Therefore, by default `dplyr`\n\n    * won't connect and query the database until absolutely necessary (e.g. show output),\n\n    * and unless explicitly told to, will only query a handful of rows to give a sense of what the result will look like.\n    \n    * we can force evaluation via `compute()`, `collect()`, or `collapse()`\n\n\n## dplyr -> SQL - `show_query()`\n\n::: {.small}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(oct_21)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_SQLiteConnection\" \"tbl_dbi\"              \"tbl_sql\"             \n[4] \"tbl_lazy\"             \"tbl\"                 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshow_query(oct_21)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `origin`, `dest`, `tailnum`\nFROM `flights`\nWHERE (`month` = 10.0) AND (`day` = 21.0)\n```\n\n\n:::\n:::\n\n\n:::\n\n## More complex queries\n\n:::: {.columns .small}\n::: {.column width='50%'}\n\n\n::: {.cell}\n\n```{.r .cell-code}\noct_21 |> \n  summarize(\n    n=n(), .by = c(origin, dest)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 3]\n# Database: sqlite 3.50.4 [flights.sqlite]\n   origin dest      n\n   <chr>  <chr> <int>\n 1 EWR    ATL      15\n 2 EWR    AUS       3\n 3 EWR    AVL       1\n 4 EWR    BNA       7\n 5 EWR    BOS      17\n 6 EWR    BTV       3\n 7 EWR    BUF       2\n 8 EWR    BWI       1\n 9 EWR    CHS       4\n10 EWR    CLE       4\n# ℹ more rows\n```\n\n\n:::\n:::\n\n\n:::\n::: {.column width='50%' .fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\noct_21 |> \n  summarize(\n    n=n(), .by = c(origin, dest)\n  ) |> \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `origin`, `dest`, COUNT(*) AS `n`\nFROM (\n  SELECT `origin`, `dest`, `tailnum`\n  FROM `flights`\n  WHERE (`month` = 10.0) AND (`day` = 21.0)\n) AS `q01`\nGROUP BY `origin`, `dest`\n```\n\n\n:::\n:::\n\n\n:::\n::::\n\n##\n\n::: {.small}\n\n\n::: {.cell}\n\n```{.r .cell-code}\noct_21 |> \n  count(origin, dest) |> \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `origin`, `dest`, COUNT(*) AS `n`\nFROM (\n  SELECT `origin`, `dest`, `tailnum`\n  FROM `flights`\n  WHERE (`month` = 10.0) AND (`day` = 21.0)\n) AS `q01`\nGROUP BY `origin`, `dest`\n```\n\n\n:::\n:::\n\n\n:::\n\n## SQL Translation \n\nIn general, dplyr / dbplyr knows how to translate basic math, logical, and summary functions from R to SQL. dbplyr has a function, `translate_sql()`, that lets you experiment with how R functions are translated to SQL. \n\n. . .\n\n::: {.xsmall}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon = dbplyr::simulate_dbi()\ndbplyr::translate_sql(x == 1 & (y < 2 | z > 3), con=con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL> `x` = 1.0 AND (`y` < 2.0 OR `z` > 3.0)\n```\n\n\n:::\n\n```{.r .cell-code}\ndbplyr::translate_sql(x ^ 2 < 10, con=con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL> (POWER(`x`, 2.0)) < 10.0\n```\n\n\n:::\n\n```{.r .cell-code}\ndbplyr::translate_sql(x %% 2 == 10, con=con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL> (`x` % 2.0) = 10.0\n```\n\n\n:::\n:::\n\n\n:::\n\n. . .\n\n::: {.xsmall}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbplyr::translate_sql(mean(x), con=con)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Missing values are always removed in SQL aggregation functions.\nUse `na.rm = TRUE` to silence this warning\nThis warning is displayed once every 8 hours.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL> AVG(`x`) OVER ()\n```\n\n\n:::\n\n```{.r .cell-code}\ndbplyr::translate_sql(mean(x, na.rm=TRUE), con=con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL> AVG(`x`) OVER ()\n```\n\n\n:::\n:::\n\n\n:::\n\n## Complications?\n\n::: {.small}\n\n\n::: {.cell}\n\n```{.r .cell-code}\noct_21 |> mutate(tailnum_n_prefix = grepl(\"^N\", tailnum))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `collect()`:\n! Failed to collect lazy table.\nCaused by error:\n! no such function: grepl\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noct_21 |> mutate(tailnum_n_prefix = grepl(\"^N\", tailnum)) |> show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `origin`, `dest`, `tailnum`, grepl('^N', `tailnum`) AS `tailnum_n_prefix`\nFROM `flights`\nWHERE (`month` = 10.0) AND (`day` = 21.0)\n```\n\n\n:::\n:::\n\n\n:::\n\n## Closing thoughts\n\nThe ability of dplyr to translate from R expression to SQL is an incredibly powerful tool making your data processing workflows portable across a wide variety of data backends.\n\nSome tools and ecosystems that are worth learning about:\n\n* Spark - [sparkR](https://spark.apache.org/docs/latest/api/R/index.html), [spark SQL](https://spark.apache.org/docs/latest/api/sql/index.html), [sparklyr](https://spark.rstudio.com/)\n\n* [DuckDB](https://duckdb.org/)\n\n* Apache [Arrow](https://arrow.apache.org/)\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}