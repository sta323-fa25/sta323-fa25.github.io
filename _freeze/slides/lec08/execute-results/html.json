{
  "hash": "9f0c06622fcbf2af4cd5271b17373fef",
  "result": {
    "markdown": "---\ntitle: \"Functional programming and purrr\"\nauthor: \"Dr. Alexander Fisher\"\nexecute:\n  warning: true\nformat: \n    revealjs:\n      smaller: true\n---\n\n\n## Announcements\n\n-   check lab solutions on Sakai\n\n-   teams for labs\n\n    -   see announcement on slack\n    -   message me by *Friday, Feb 10* if you'd like to be pseudo-randomly assigned a team or\n    -   reach out to any member of the teaching team if you'd like to form a specific team.\n\n-   quiz 03\n\n# Functionals\n\n## Function as objects\n\nFunctions are first class objects (like vectors).\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nf = function(x) {\n  x ^ 2\n}\ng = f\ng(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nl = list(f = f, g = g)\nl$f(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nl[[2]](4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nl[1](3)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): attempt to apply non-function\n```\n:::\n:::\n\n:::\n:::\n\n## Functions as arguments\n\nA **functional** is a function that takes a function as an input and returns a vector as output.\n\nExample: `lapply()` and `sapply()` accept function arguments.\n\n-   `lapply()`, as the name suggests applies a function over a list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = list( c(1,2,3), b = c(10, 20, 30, 40, 50))\nlapply(x, mean) # output is a list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2\n\n$b\n[1] 30\n```\n:::\n:::\n\n\n-   `sapply()` works the same but returns a *simpler* output\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(x, mean) # output is a vector of doubles\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    b \n 2 30 \n```\n:::\n:::\n\n\n## Functions as output\n\nWe can make a function return another function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf = function (n) {\n  # function returns \n  # function that raises its argument to the n power\n  g = function(x) {\n    return(x ^ n)\n  }\n  return(g)\n}\n\nf(3)(2) # 2 ^ 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n\n## Anonymous functions (lambdas)\n\nThese are short functions that are created without ever assigning a name\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction(x) {x + 1}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction(x) {x + 1}\n```\n:::\n\n```{.r .cell-code}\n(function(y) {y - 1})(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n:::\n\n\nIdea: won't create an object we don't need. This is especially useful for passing a function as an argument.\n\n. . .\n\nExample: numerical derivatives\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintegrate(function(x) x, 0, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.5 with absolute error < 5.6e-15\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintegrate(function(x) (x * x) - (2 * x) + 1, 0, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.3333333 with absolute error < 3.7e-15\n```\n:::\n:::\n\n\n## Base R lambda shorthand\n\nAlong with the base pipe (`|>`), R v4.1.0 introduced a shortcut for anonymous functions using `\\()`, we won't be using this for the same reason but it is useful to know that it exists.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf = \\(x) {1 + x}\nf(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4 5 6\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(\\(x) x ^ 2)(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 100\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nintegrate(\\(x) sin(x) ^ 2, 0, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.2726756 with absolute error < 3e-15\n```\n:::\n:::\n\n\nUse of this with the base pipe is meant avoid the need for `.`, e.g.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(x = runif(10), y = runif(10)) |>\n  {\\(d) lm(y ~ x, data = d)}()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x, data = d)\n\nCoefficients:\n(Intercept)            x  \n     0.2556       0.6520  \n```\n:::\n:::\n\n\n# apply (base R)\n\n## apply functions\n\nThe apply functions are a collection of tools for functional programming in base R, they are variations of the `map` function found in many other languages and apply a function over the elements of the input (vector).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n??base::apply\n---\n## \n## Help files with alias or concept or title matching ‘apply’ using fuzzy\n## matching:\n## \n## base::apply             Apply Functions Over Array Margins\n## base::.subset           Internal Objects in Package 'base'\n## base::by                Apply a Function to a Data Frame Split by Factors\n## base::eapply            Apply a Function Over Values in an Environment\n## base::lapply            Apply a Function over a List or Vector\n## base::mapply            Apply a Function to Multiple List or Vector Arguments\n## base::rapply            Recursively Apply a Function to a List\n## base::tapply            Apply a Function Over a Ragged Array\n```\n:::\n\n\n-   applies function in an iterative format\n\n## `lapply` and `sapply`\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(1:4, function(x, pow) x ^ pow, pow = 2) %>% str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 4\n $ : num 1\n $ : num 4\n $ : num 9\n $ : num 16\n```\n:::\n\n```{.r .cell-code}\nlapply(1:4, function(x, pow) x ^ pow, x = 2) %>% str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 4\n $ : num 2\n $ : num 4\n $ : num 8\n $ : num 16\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(1:8, function(x) (x + 1) ^ 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4  9 16 25 36 49 64 81\n```\n:::\n\n```{.r .cell-code}\nsapply(1:8, function(x) c(x, x ^ 2, x ^ 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]\n[1,]    1    2    3    4    5    6    7    8\n[2,]    1    4    9   16   25   36   49   64\n[3,]    1    8   27   64  125  216  343  512\n```\n:::\n:::\n\n\n## \n\nWhat happens if the returned lengths don't match?\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(1:3, seq)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 1 2\n\n[[3]]\n[1] 1 2 3\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(1:3, seq) %>% str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ : int 1\n $ : int [1:2] 1 2\n $ : int [1:3] 1 2 3\n```\n:::\n:::\n\n:::\n:::\n\n. . .\n\nWhat happens if the types don't match?\n\n. . .\n\ntype coercion!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl = list(a = 1:3, b = 4:6, c = 7:9, d = list(10, 11, \"A\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(l, function(x) x[1]) %>% str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 4\n $ a: int 1\n $ b: int 4\n $ c: int 7\n $ d: num 10\n```\n:::\n:::\n\n\n-   type consistency issue: can't quickly see return type\n\n## \\*apply and data frames\n\nCommon use case: data frames\n\n-   recall: a data frames is just a fancy list\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf = data.frame(\n  a = 1:6, \n  b = letters[1:6], \n  c = c(TRUE,FALSE)\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(df, class) %>% str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ a: chr \"integer\"\n $ b: chr \"character\"\n $ c: chr \"logical\"\n```\n:::\n\n```{.r .cell-code}\nsapply(df, class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          a           b           c \n  \"integer\" \"character\"   \"logical\" \n```\n:::\n:::\n\n\n## A more useful example\n\nPenalized regression: the lasso\n\n\n$$\n\\min_{\\beta \\in \\mathcal{R^p}} ||y - X\\beta||_2^2  + \\lambda||\\beta||_1\n$$\n\n\n. . .\n\nIt only makes sense to \"shrink\" the $\\beta_i$s if the predictors are on the same scale. Therefore we want to standardize the data in matrix X, e.g.\n\n    for each column j in X: \n      for each row i:\n        recompute x[i, j] = x[i, j] - mean(x[,j]) / sd(x[,j])\n        \n\n. . .\n\nWe can solve this elegantly with an \\*apply.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX = data.frame(height = c(72, 60, 64),\n               bpm = c(82, 55, 60))\n```\n:::\n\n\n::: panel-tabset\n### apply\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(X, 2, function(x) (x - mean(x)) / sd(x)) # returns matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         height        bpm\n[1,]  1.0910895  1.1370777\n[2,] -0.8728716 -0.7425813\n[3,] -0.2182179 -0.3944963\n```\n:::\n:::\n\n\n### lapply\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(X, function (x) (x - mean(x)) / sd(x)) %>% \n  as.data.frame() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      height        bpm\n1  1.0910895  1.1370777\n2 -0.8728716 -0.7425813\n3 -0.2182179 -0.3944963\n```\n:::\n:::\n\n:::\n\n## other less common apply functions\n\n-   `apply()` - applies a function over the rows or columns of a data frame, matrix or array\n\n-   `vapply()` - is similar to `sapply`, but has a enforced return type and size\n\n-   `mapply()` - like `sapply` but will iterate over multiple vectors at the same time.\n\n-   `rapply()` - a recursive version of `lapply`, behavior depends largely on the `how` argument\n\n-   `eapply()` - apply a function over an environment.\n\n# purrr\n\n![](images/purrr-logo.png){fig-align=\"center\"}\n\n## Map functions\n\n- replacements for `lapply`/`sapply`/`vapply`\n\n* `map()` - returns a list (same as `lapply`)\n\n* `map_lgl()` - returns a logical vector.\n\n* `map_int()` - returns a integer vector.\n\n* `map_dbl()` - returns a double vector.\n\n* `map_chr()` - returns a character vector.\n\n* `map_dfr()` - returns a data frame by row binding.\n\n* `map_dfc()` - returns a data frame by column binding.\n\n* `walk()` - returns nothing,  used exclusively for function side effects\n\n## Type consistency\n\nR is a weakly / dynamically typed language which means there is no syntactic way to define a function which enforces argument or return types. This flexibility can be useful at times, but often it makes it hard to reason about your code and requires more verbose code to handle edge cases.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nx = list(rnorm(1e3), rnorm(1e3), rnorm(1e3))\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(x, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0.01612787  0.04246525 -0.02011253\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_chr(x, mean)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Automatic coercion from double to character was deprecated in purrr 1.0.0.\nℹ Please use an explicit call to `as.character()` within `map_chr()` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0.016128\"  \"0.042465\"  \"-0.020113\"\n```\n:::\n:::\n\n\n. . .\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_int(x, mean)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `map_int()`:\nℹ In index: 1.\nCaused by error:\n! Can't coerce from a double vector to an integer vector.\n```\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(x, mean) %>% str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ : num 0.0161\n $ : num 0.0425\n $ : num -0.0201\n```\n:::\n:::\n\n:::\n:::\n\n## Working with Data Frames\n\n`map_dfr` and `map_dfc` are particularly useful when working with and/or creating data frames. \nExample:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX = data.frame(height = c(72, 60, 64),\n               bpm = c(82, 55, 60),\n               age = c(25, 30, 35))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstandardize = function(x) (x - mean(x)) / sd(x)\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dfc(X, standardize)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  height    bpm   age\n   <dbl>  <dbl> <dbl>\n1  1.09   1.14     -1\n2 -0.873 -0.743     0\n3 -0.218 -0.394     1\n```\n:::\n:::\n\n\n. . .\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dfr(X, function(x) x[1:2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  height   bpm   age\n   <dbl> <dbl> <dbl>\n1     72    82    25\n2     60    55    30\n```\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dfr(X, function(x) x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  height   bpm   age\n   <dbl> <dbl> <dbl>\n1     72    82    25\n2     60    55    30\n3     64    60    35\n```\n:::\n:::\n\n:::\n:::\n\n## Shortcut - purrr style lambdas\n\npurrr lets us write anonymous functions using one sided formulas where the argument is given by `.` or `.x` for `map` and related functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(1:5, function(x) x / (x + 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5000000 0.6666667 0.7500000 0.8000000 0.8333333\n```\n:::\n:::\n\n\n. . .\n\nRead `~` as \"function\" and `.` or `.x` as \"input\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(1:5, ~ . / (. + 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5000000 0.6666667 0.7500000 0.8000000 0.8333333\n```\n:::\n:::\n\n\n. . . \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(1:5, ~ .x / (.x + 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5000000 0.6666667 0.7500000 0.8000000 0.8333333\n```\n:::\n:::\n\n\nGenerally, the latter option is preferred to avoid confusion with magrittr.\n\n## Multiargument anonymous functions\n\nFunctions with the `map2` prefix work the same as the `map` functions but they iterate over two objects instead of one. Arguments in an anonymous function are given by `.x` and `.y` (or `..1` and `..2`) respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap2_dbl(1:5, 1:5, function(x,y) x / (y+1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5000000 0.6666667 0.7500000 0.8000000 0.8333333\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap2_dbl(1:5, 1:5, ~ .x/(.y+1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5000000 0.6666667 0.7500000 0.8000000 0.8333333\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap2_dbl(1:5, 1:5, ~ ..1/(..2+1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5000000 0.6666667 0.7500000 0.8000000 0.8333333\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap2_chr(LETTERS[1:5], letters[1:5], paste0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Aa\" \"Bb\" \"Cc\" \"Dd\" \"Ee\"\n```\n:::\n:::\n\n\n. . . \n\nPrioritize readability of your code! For complicated functions, use syntax like the first example.\n\n## Lookups (`sw_people`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(repurrrsive)\n```\n:::\n\n\n`sw_people` from the `repurrrsive` package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(sw_people[1:5])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 5\n $ :List of 16\n  ..$ name      : chr \"Luke Skywalker\"\n  ..$ height    : chr \"172\"\n  ..$ mass      : chr \"77\"\n  ..$ hair_color: chr \"blond\"\n  ..$ skin_color: chr \"fair\"\n  ..$ eye_color : chr \"blue\"\n  ..$ birth_year: chr \"19BBY\"\n  ..$ gender    : chr \"male\"\n  ..$ homeworld : chr \"http://swapi.co/api/planets/1/\"\n  ..$ films     : chr [1:5] \"http://swapi.co/api/films/6/\" \"http://swapi.co/api/films/3/\" \"http://swapi.co/api/films/2/\" \"http://swapi.co/api/films/1/\" ...\n  ..$ species   : chr \"http://swapi.co/api/species/1/\"\n  ..$ vehicles  : chr [1:2] \"http://swapi.co/api/vehicles/14/\" \"http://swapi.co/api/vehicles/30/\"\n  ..$ starships : chr [1:2] \"http://swapi.co/api/starships/12/\" \"http://swapi.co/api/starships/22/\"\n  ..$ created   : chr \"2014-12-09T13:50:51.644000Z\"\n  ..$ edited    : chr \"2014-12-20T21:17:56.891000Z\"\n  ..$ url       : chr \"http://swapi.co/api/people/1/\"\n $ :List of 14\n  ..$ name      : chr \"C-3PO\"\n  ..$ height    : chr \"167\"\n  ..$ mass      : chr \"75\"\n  ..$ hair_color: chr \"n/a\"\n  ..$ skin_color: chr \"gold\"\n  ..$ eye_color : chr \"yellow\"\n  ..$ birth_year: chr \"112BBY\"\n  ..$ gender    : chr \"n/a\"\n  ..$ homeworld : chr \"http://swapi.co/api/planets/1/\"\n  ..$ films     : chr [1:6] \"http://swapi.co/api/films/5/\" \"http://swapi.co/api/films/4/\" \"http://swapi.co/api/films/6/\" \"http://swapi.co/api/films/3/\" ...\n  ..$ species   : chr \"http://swapi.co/api/species/2/\"\n  ..$ created   : chr \"2014-12-10T15:10:51.357000Z\"\n  ..$ edited    : chr \"2014-12-20T21:17:50.309000Z\"\n  ..$ url       : chr \"http://swapi.co/api/people/2/\"\n $ :List of 14\n  ..$ name      : chr \"R2-D2\"\n  ..$ height    : chr \"96\"\n  ..$ mass      : chr \"32\"\n  ..$ hair_color: chr \"n/a\"\n  ..$ skin_color: chr \"white, blue\"\n  ..$ eye_color : chr \"red\"\n  ..$ birth_year: chr \"33BBY\"\n  ..$ gender    : chr \"n/a\"\n  ..$ homeworld : chr \"http://swapi.co/api/planets/8/\"\n  ..$ films     : chr [1:7] \"http://swapi.co/api/films/5/\" \"http://swapi.co/api/films/4/\" \"http://swapi.co/api/films/6/\" \"http://swapi.co/api/films/3/\" ...\n  ..$ species   : chr \"http://swapi.co/api/species/2/\"\n  ..$ created   : chr \"2014-12-10T15:11:50.376000Z\"\n  ..$ edited    : chr \"2014-12-20T21:17:50.311000Z\"\n  ..$ url       : chr \"http://swapi.co/api/people/3/\"\n $ :List of 15\n  ..$ name      : chr \"Darth Vader\"\n  ..$ height    : chr \"202\"\n  ..$ mass      : chr \"136\"\n  ..$ hair_color: chr \"none\"\n  ..$ skin_color: chr \"white\"\n  ..$ eye_color : chr \"yellow\"\n  ..$ birth_year: chr \"41.9BBY\"\n  ..$ gender    : chr \"male\"\n  ..$ homeworld : chr \"http://swapi.co/api/planets/1/\"\n  ..$ films     : chr [1:4] \"http://swapi.co/api/films/6/\" \"http://swapi.co/api/films/3/\" \"http://swapi.co/api/films/2/\" \"http://swapi.co/api/films/1/\"\n  ..$ species   : chr \"http://swapi.co/api/species/1/\"\n  ..$ starships : chr \"http://swapi.co/api/starships/13/\"\n  ..$ created   : chr \"2014-12-10T15:18:20.704000Z\"\n  ..$ edited    : chr \"2014-12-20T21:17:50.313000Z\"\n  ..$ url       : chr \"http://swapi.co/api/people/4/\"\n $ :List of 15\n  ..$ name      : chr \"Leia Organa\"\n  ..$ height    : chr \"150\"\n  ..$ mass      : chr \"49\"\n  ..$ hair_color: chr \"brown\"\n  ..$ skin_color: chr \"light\"\n  ..$ eye_color : chr \"brown\"\n  ..$ birth_year: chr \"19BBY\"\n  ..$ gender    : chr \"female\"\n  ..$ homeworld : chr \"http://swapi.co/api/planets/2/\"\n  ..$ films     : chr [1:5] \"http://swapi.co/api/films/6/\" \"http://swapi.co/api/films/3/\" \"http://swapi.co/api/films/2/\" \"http://swapi.co/api/films/1/\" ...\n  ..$ species   : chr \"http://swapi.co/api/species/1/\"\n  ..$ vehicles  : chr \"http://swapi.co/api/vehicles/30/\"\n  ..$ created   : chr \"2014-12-10T15:20:09.791000Z\"\n  ..$ edited    : chr \"2014-12-20T21:17:50.315000Z\"\n  ..$ url       : chr \"http://swapi.co/api/people/5/\"\n```\n:::\n:::\n\n\n## Lookups\n\nVery often we want to extract only certain (named) values from a list, `purrr` provides a shortcut for this operation - if instead of a function you provide either a character or numeric vector, those values will be used to sequentially subset the elements being iterated.\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_chr(sw_people, \"name\") %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Luke Skywalker\" \"C-3PO\"          \"R2-D2\"          \"Darth Vader\"   \n[5] \"Leia Organa\"    \"Owen Lars\"     \n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_chr(sw_people, 1) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Luke Skywalker\" \"C-3PO\"          \"R2-D2\"          \"Darth Vader\"   \n[5] \"Leia Organa\"    \"Owen Lars\"     \n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_chr(sw_people, list(\"films\", 1)) %>% head(n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"http://swapi.co/api/films/6/\" \"http://swapi.co/api/films/5/\"\n [3] \"http://swapi.co/api/films/5/\" \"http://swapi.co/api/films/6/\"\n [5] \"http://swapi.co/api/films/6/\" \"http://swapi.co/api/films/5/\"\n [7] \"http://swapi.co/api/films/5/\" \"http://swapi.co/api/films/1/\"\n [9] \"http://swapi.co/api/films/1/\" \"http://swapi.co/api/films/5/\"\n```\n:::\n:::\n\n## Length coercion?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_chr(sw_people, list(\"starships\", 1))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `purrr::map_chr()`:\nℹ In index: 2.\nCaused by error:\n! Result must be length 1, not 0.\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsw_people[[2]]$name\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"C-3PO\"\n```\n:::\n\n```{.r .cell-code}\nsw_people[[2]]$starships\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(sw_people, list(\"starships\", 1)) %>% head(n = 3) %>% str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ : chr \"http://swapi.co/api/starships/12/\"\n $ : NULL\n $ : NULL\n```\n:::\n:::\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_chr(sw_people, list(\"starships\", 1), .default = NA) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"http://swapi.co/api/starships/12/\" NA                                 \n[3] NA                                  \"http://swapi.co/api/starships/13/\"\n[5] NA                                  NA                                 \n```\n:::\n:::\n\n\n## manual unnesting\n\n- how many starships does each character have?\n\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n(chars = tibble(\n  name = purrr::map_chr(sw_people, \"name\"),\n  starships = purrr::map(sw_people, \"starships\")\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 2\n   name               starships\n   <chr>              <list>   \n 1 Luke Skywalker     <chr [2]>\n 2 C-3PO              <NULL>   \n 3 R2-D2              <NULL>   \n 4 Darth Vader        <chr [1]>\n 5 Leia Organa        <NULL>   \n 6 Owen Lars          <NULL>   \n 7 Beru Whitesun lars <NULL>   \n 8 R5-D4              <NULL>   \n 9 Biggs Darklighter  <chr [1]>\n10 Obi-Wan Kenobi     <chr [5]>\n# … with 77 more rows\n```\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nchars %>%\n  mutate(n = map_int(starships, length))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 3\n   name               starships     n\n   <chr>              <list>    <int>\n 1 Luke Skywalker     <chr [2]>     2\n 2 C-3PO              <NULL>        0\n 3 R2-D2              <NULL>        0\n 4 Darth Vader        <chr [1]>     1\n 5 Leia Organa        <NULL>        0\n 6 Owen Lars          <NULL>        0\n 7 Beru Whitesun lars <NULL>        0\n 8 R5-D4              <NULL>        0\n 9 Biggs Darklighter  <chr [1]>     1\n10 Obi-Wan Kenobi     <chr [5]>     5\n# … with 77 more rows\n```\n:::\n:::\n\n:::\n:::\n\n- much more efficient if you only need a subset of the columns to be \"unnested\"\n\n# Exercises\n\n## Exercise 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndraw_points = function(n) {\n  list(\n    x = runif(n, -1, 1),\n    y = runif(n, -1, 1)\n  )\n}\n```\n:::\n\n\n- Use the function above to draw `n = 1000` points from a box of area 4. Save your output as an object called `points`.\n- Use `map` or an appropriate version to determine which points $(x, y)$ are within the unit circle centered at the origin.\n- What proportion of points are within the unit circle?\n\n- Can you approximate $\\pi$ like this? How?\n- How can you make your estimate more precise?\n\n## Exercise 2\n\nUse `mtcars` and a single `map` or map variant to\n\n- get the type of each variable\n\n- get the fourth row such that result is a character vector\n\n- compute the mean of each variable\n\n- compute the mean and median for each variable such that the result is a data frame with the mean values in row 1 and the median values in row 2.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    function fireSlideChanged(previousSlide, currentSlide) {\n\n      // dispatch for htmlwidgets\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for reveal\n    if (window.Reveal) {\n      window.Reveal.addEventListener(\"slidechanged\", function(event) {\n        fireSlideChanged(event.previousSlide, event.currentSlide);\n      });\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}