{
  "hash": "125447de34d11d3f54978fd7f49622c0",
  "result": {
    "markdown": "---\ntitle: \"Subsetting\"\nauthor: \"Dr. Alexander Fisher\"\nexecute:\n  warning: true\nformat: \n    revealjs:\n      smaller: true\n---\n\n\n## Announcements\n\n-   exam 1 date on [schedule](/schedule.html)\n\n. . .\n\n-   quiz 02\n\n# Subsetting\n\n## Subsetting in general\n\nR has three subsetting operators (`[`, `[[`, and `$`). The behavior of these operators will depend on the object (class) they are being used with.\n\n. . .\n\nIn general there are 6 different types of subsetting that can be performed:\n\n::: columns\n::: {.column width=\"50%\"}\n-   Positive integer\n\n-   Negative integer\n\n-   Logical value\n:::\n\n::: {.column width=\"50%\"}\n-   Empty\n\n-   Zero valued / NULL\n\n-   Character value (names)\n:::\n:::\n\n# `[`\n\n## Integer subsetting: values by index\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1,4,7); y = list(1,4,7)\n```\n:::\n\n\n::: columns\n::: {.column width=\"50%\"}\n#### Positive subsetting\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1] # subset a vector get a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nx[c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 7\n```\n:::\n\n```{.r .cell-code}\nx[c(1.9, 2.1)] # coercion\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(y[1]) # subset a list get a list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ : num 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(y[c(1.9, 2.1)]) # coercion\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ : num 1\n $ : num 4\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n::: fragment\n#### Negative (exclusionary) subsetting\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 7\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(y[-c(1,2)])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ : num 7\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(-1,2)]\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in x[c(-1, 2)]: only 0's may be mixed with negative subscripts\n```\n:::\n:::\n\n\nYou can't mix positive and negative values!\n:::\n:::\n:::\n\nNote that R starts indexing at 1.\n\n## Logical subsetting\n\nReturns values that correspond to `TRUE` in the logical vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 4, 7, 12)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(TRUE, FALSE, TRUE, FALSE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 7\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(TRUE, FALSE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 7\n```\n:::\n:::\n\n\n. . .\n\n#### Utility of this\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[x %% 2 == 0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4 12\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::glimpse(cars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 50\nColumns: 2\n$ speed <dbl> 4, 4, 7, 7, 8, 9, 10, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13…\n$ dist  <dbl> 2, 10, 4, 22, 16, 10, 18, 26, 34, 17, 28, 14, 20, 24, 28, 26, 34…\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncars_with_high_speed = \n  cars[cars$speed > 9,]\n```\n:::\n\n\n## Empty and zero subsetting\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 4, 7); y = list(1, 4, 7)\n```\n:::\n\n\n::: columns\n::: {.column width=\"50%\"}\n#### Empty\n\nReturns the original vector, this is not the same thing as subsetting with NULL.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4 7\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(y[])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ : num 1\n $ : num 4\n $ : num 7\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n#### Zero subsetting\n\nSame as subsetting with `NULL`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[NULL]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nnumeric(0)\n```\n:::\n\n```{.r .cell-code}\nx[0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nnumeric(0)\n```\n:::\n\n```{.r .cell-code}\nstr(y[NULL])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n list()\n```\n:::\n\n```{.r .cell-code}\nstr(y[0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n list()\n```\n:::\n:::\n\n:::\n:::\n\n## Character value subsetting\n\nIf the vector has names, selects elements whose names correspond to the values in the character vector.\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(a = 1, b = 4, c = 7)\n\nx[\"a\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na \n1 \n```\n:::\n\n```{.r .cell-code}\nx[c(\"a\", \"a\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na a \n1 1 \n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ny = list(a = 1, b = 4, c = 7)\nstr(y[c(\"b\", \"c\")])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ b: num 4\n $ c: num 7\n```\n:::\n:::\n\n:::\n:::\n\nThis is a great way to subset because position is fragile, but the name is usually more robust as we manipulate our object.\n\n## Breaking subsetting\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 4, 7); y = list(1, 4, 7)\n```\n:::\n\n\n::: columns\n::: {.column width=\"50%\"}\n#### Out of bounds\n\n-   returns NA for atomic vector\n-   returns NULL for generic vector (list)\n-   no warning!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nx[-4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4 7\n```\n:::\n\n```{.r .cell-code}\nstr(y[4])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ : NULL\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n::: fragment\n#### Missing\n\nSubset with a missing value, we will get back a missing value (atomic vector) or `NULL` (list).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[NA] # logical subsetting with length coercion\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA\n```\n:::\n\n```{.r .cell-code}\nx[c(1,NA)] # integer subsetting\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 NA\n```\n:::\n\n```{.r .cell-code}\nstr(y[NA])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ : NULL\n $ : NULL\n $ : NULL\n```\n:::\n:::\n\n:::\n:::\n:::\n\n# `[[` and `$`\n\n## `[[`\n\n::: columns\n::: {.column width=\"50%\"}\n#### Atomic vectors\n\n`[[` subsets like `[` except it can only subset for a single value\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(a = 1, b = 4, c = 7)\n\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na \n1 \n```\n:::\n\n```{.r .cell-code}\nx[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nx[[TRUE]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nx[[1:2]]\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in x[[1:2]]: attempt to select more than one element in vectorIndex\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n::: fragment\n#### Generic vectors\n\n`[[` subsets a single value, but returns the value - not a list containing that value like `[`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny = list(a = 1, b = 4, c = 7:9)\ny[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$b\n[1] 4\n```\n:::\n\n```{.r .cell-code}\ny[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\ny[[1:2]]\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in y[[1:2]]: subscript out of bounds\n```\n:::\n\n```{.r .cell-code}\ny[[c(2,1)]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n:::\n:::\n:::\n\n## Hadley's analogy 1\n\n![](images/list_train1.png){width=\"500\" fig-align=\"center\"}\n\n. . .\n\n![](images/list_train2.png){width=\"500\" fig-align=\"center\"}\n\n. . .\n\n![](images/list_train3.png){width=\"500\" fig-align=\"center\"}\n\n## Hadley's analogy 2 \n\n![](images/pepper_subset.png){fig-align=\"center\"}\n\n## `[[` vs `$`\n\n`$` is equivalent to `[[` but it only works for named *lists* and it uses partial matching for names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(\"abc\" = 1, \"def\" = 5)\nx$abc\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in x$abc: $ operator is invalid for atomic vectors\n```\n:::\n:::\n\n\n. . .\n\n`$` is only for generic vectors\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny = list(\"abc\" = 1, \"def\" = 5)\ny[[\"abc\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\ny$abc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\ny$d \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n. . .\n\nBe careful of the last one!\n\n## A common error\n\nWhy does the following code not work?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = list(abc = 1:10, def = 10:1)\ny = \"abc\"\n```\n:::\n\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx[[y]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx$y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n:::\n:::\n\n. . .\n\nThe expression `x$y` gets directly interpreted as `x[[\"y\"]]` by R, note the inclusion of the `\"`s, this is not the same as the expression `x[[y]]`.\n\n## Exercise\n\nBelow are 100 values,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(56, 3, 17, 2, 4, 9, 6, 5, 19, 5, 2, 3, 5, 0, 13, 12, 6, \n      31, 10, 21, 8, 4, 1, 1, 2, 5, 16, 1, 3, 8, 1,\n      3, 4, 8, 5, 2, 8, 6, 18, 40, 10, 20, 1, 27, 2, 11, 14, 5, 7, \n      0, 3, 0, 7, 0, 8, 10, 10, 12, 8, 82,\n      21, 3, 34, 55, 18, 2, 9, 29, 1, 4, 7, 14, 7, 1, 2, 7, \n      4, 74, 5, 0, 3, 13, 2, 8, 1, 6, 13, 7, 1, 10,\n      5, 2, 4, 4, 14, 15, 4, 17, 1, 9)\n```\n:::\n\n\nsubset to accomplish each of the following:\n\n-   Select every third value starting at position 2 in x. The first three entries should be `3, 4, 5`\n\n-   Remove all values with an odd **index** (e.g. 1, 3, etc.)\n\n-   Remove every 4th value, but only if it is odd.\n\n## Subsetting data frames\n\nSince data frames have two dimensions, we can subset either rows, columns or both.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(df = data.frame(x = 1:3, y = c(\"A\",\"B\",\"C\"), z = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y    z\n1 1 A TRUE\n2 2 B TRUE\n3 3 C TRUE\n```\n:::\n:::\n\n\n::: columns\n::: {.column width=\"50%\"}\n#### Subset rows\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[1, ] # first row\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y    z\n1 1 A TRUE\n```\n:::\n\n```{.r .cell-code}\ndf[c(1,3), ] # first and third row\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y    z\n1 1 A TRUE\n3 3 C TRUE\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n#### Subset columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[, 1] # first column\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\ndf[, 1:2] # first through second column\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y\n1 1 A\n2 2 B\n3 3 C\n```\n:::\n:::\n\n:::\n:::\n\n. . .\n\n#### Subset both\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[1:2,1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y\n1 1 A\n2 2 B\n```\n:::\n:::\n\n\n## Preserving vs simplifying\n\nMost of the time, R's `[` is a **preserving** operator, in that the returned object will always have the same type/class as the object being subset.\n\nConfusingly, when used with some classes (e.g. data frame, matrix or array) `[` becomes a **simplifying operator** (does not preserve type) - this behavior is instead controlled by the drop argument.\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars |>\n  head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  speed dist\n1     4    2\n2     4   10\n3     7    4\n```\n:::\n:::\n\n\n::: columns\n::: {.column width=\"50%\"}\nfor columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(cars[, 1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n num [1:50] 4 4 7 7 8 9 10 10 10 11 ...\n```\n:::\n\n```{.r .cell-code}\nstr(cars[, 1, drop = FALSE])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t50 obs. of  1 variable:\n $ speed: num  4 4 7 7 8 9 10 10 10 11 ...\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n::: fragment\nfor rows it's the opposite:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(cars[1, ])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t1 obs. of  2 variables:\n $ speed: num 4\n $ dist : num 2\n```\n:::\n\n```{.r .cell-code}\nstr(cars[1, , drop = TRUE])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ speed: num 4\n $ dist : num 2\n```\n:::\n:::\n\n:::\n:::\n:::\n\n## Preserving vs simplifying summary\n\n| Type           | Simplifying                            | Preserving                                      |\n|:-----------------|:-----------------|:-----------------------------------|\n| Atomic Vector  | `x[[1]]`                               | `x[1]`                                          |\n| List           | `x[[1]]`                               | `x[1]`                                          |\n| Matrix / Array | `x[[1]]` <br/> `x[1, ]` <br/> `x[, 1]` | `x[1, , drop=FALSE]` <br/> `x[, 1, drop=FALSE]` |\n| Factor         | `x[1:4, drop=TRUE]`                    | `x[1:4]` <br/> `x[[1]]`                         |\n| Data frame     | `x[, 1]` <br/> `x[[1]]`                | `x[, 1, drop=FALSE]` <br/> `x[1]`               |\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    function fireSlideChanged(previousSlide, currentSlide) {\n\n      // dispatch for htmlwidgets\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for reveal\n    if (window.Reveal) {\n      window.Reveal.addEventListener(\"slidechanged\", function(event) {\n        fireSlideChanged(event.previousSlide, event.currentSlide);\n      });\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}