{
  "hash": "6fa0482407208c6fb2bb263bb18d4b7b",
  "result": {
    "markdown": "---\ntitle: \"MM Algorithm Example\"\nauthor: \"Dr. Alexander Fisher\"\nexecute:\n  warning: true\nformat: \n    revealjs:\n      smaller: true\n---\n\n\n## Announcements\n\n- [project instructions released](/project.html)\n\n# Examples\n\n## Bradley-Terry model \n\n- Predicts the outcome of a paired comparison. \n\n. . .\n\nGiven two individuals $i$ and $j$ drawn from some population, the Bradley-Terry model estimates the probability that the pairwise comparison $i > j$ turns out true, as\n\n\n$$\nPr(i > j) = \\frac{p_i}{p_i + p_j},\n$$\n\n\nwhere $p_i$ is a positive real-valued score assigned to individual i. The comparison $i > j$ can be read as \"$i$ is preferred to $j$\", \"$i$ ranks higher than $j$\", or \"$i$ beats $j$\", depending on the application.\n\n<!-- . . .  -->\n\n<!-- In some settings, you may see written $p_i = e^{\\beta_i}$ so that -->\n\n<!-- $$ -->\n<!-- Pr(i > j) = \\frac{e^{\\beta_i}}{e^{\\beta_i} + e^{\\beta_j}}. -->\n<!-- $$ -->\n<!-- . . .  -->\n\n<!-- What's nice about this re-parameterization? -->\n\n## Bradley-Terry Application\n\nOne popular application of the Bradley-Terry model is ranking sports teams. We are interested modeling the **outcome** of previous match ups.\n\n### Example data:\n\n\n\n::: {.cell}\n\n:::\n\n\nAll 1230 regular season NBA games (82 games per team, 30 teams: 82 * 30 /2) from 2015-2016.[^1]\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1,230\nColumns: 3\n$ Home <dbl> 1, 5, 10, 22, 2, 3, 9, 16, 28, 11, 15, 17, 21, 24, 25, 26, 14, 12…\n$ Away <dbl> 9, 6, 19, 30, 23, 5, 29, 4, 12, 8, 6, 20, 27, 7, 19, 13, 18, 15, …\n$ Y    <dbl> 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1,…\n```\n:::\n:::\n\n**Code book:**\n\n- `Home`: unique id for home team\n- `Away`: unique id for away team\n- `Y`: whether the home team won (1) or lost (0)\n\n. . . \n\nRead in this data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNBA = read_csv(\"https://sta323-sp23.github.io/data/NBA_1516.csv\")\nteam_id = read_csv(\"https://sta323-sp23.github.io/data/teams.csv\")\n```\n:::\n\n\n[^1]: data sourced from [Dr. Zhou Fan's inference course here](https://web.stanford.edu/class/stats200/index.html)\n\n## Bradley-Terry with home-court advantage\n\nThe most basic Bradley-Terry model does not account for ties, which is fine for our basketball example. However, it would be nice to model and assess the contribution of home-court advantage.\n\n\n$$\n\\text{Pr(i beats j at home)} = \\frac{\\theta p_i}{\\theta p_i + p_j}\n$$\n\n$$\n\\text{Pr(i loses to j at home)} = \\frac{p_j}{\\theta p_i + p_j}.\n$$\n\n\nHere, $\\theta \\in [0, 1]$ corresponds to home-court advantage.\n\n. . .\n\n#### Check your understanding\n\n- What does $\\theta = 0$ and $\\theta = 1$ correspond to?\n\n- What assumptions have we made about home-court advantage in this model?\n\n## Bradley-Terry likelihood\n\nLet $a_{ij}$ be the number of times team $i$ beats team $j$ at home and let $b_{ij}$ be the number of times team $i$ loses to team $j$ at home.  Assuming all the games are independent, we write the log-likelihood of the Bradley Terry model with home-court advantage,\n\n\n$$\n\\log L(\\mathbf{p}, \\theta) = \\sum_{i} \\sum_{j} a_{ij} \\ln \\left( \\frac{\\theta p_i}{\\theta p_i + p_j} \\right)\n+ b_{ij} \\ln \\left(\\frac{p_j}{\\theta p_i + p_j} \\right)\n$$\n\n. . .\n\n\nLet $w_i$ be the total number of wins by team $i$ and let $h = \\sum_{i} \\sum_{j} a_{ij}$ be the total number of home-court wins across all teams. \n\nWe can re-formulate the log-likelihood,\n\n\n$$\n\\log L(\\mathbf{p}, \\theta) = h \\ln \\theta + \\sum_{i} w_i \\ln p_i - \\sum_{i} \\sum_{j} (a_{ij} + b_{ij}) \\ln (\\theta p_i + p_j)\n$$\n\n. . . \n\nHint for algebra: $w_i = \\sum_i \\sum_j \\left[a_{ij} \\ln p_i + b_{ij} \\ln p_j \\right]$.\n\n. . . \n\n#### Reminder\n\n- We are interested in estimating the home field advantage parameter $\\theta$ and team ranking parameters $\\mathbf{p} = \\{p_1, \\ldots, p_n\\}$ where $n$ is the total number of teams. The team with the largest $\\hat{p_i}$ will be the best team.\n\n## Minorize-maximize the likelihood\n\n#### Notice\n\n- As a side note, notice that the team rank parameter $\\mathbf{p}$ is invariant to re-scaling in the log-likelihood. In other words, we can scale all $p_i$ by a constant and obtain the same rank order of the estimates. Without loss of generality, we can set $p_1$ = c and then all other team rankings will be defined relative to the first team. This is a way we can eliminate 1 degree of freedom in our model parameters.\n\n. . . \n\n#### By the supporting line minorization\n\n\n$$\n- \\ln (\\theta p_i + p_j) \\geq - \\ln (\\theta_n p_{ni} + p_{nj}) - \n\\frac{(\\theta p_i + p_j) - (\\theta_n p_{ni} + p_{nj})}{\\theta_n p_{ni} + p_{nj}}\n$$\n\nIf we instead subtract the RHS, we are subtracting something 'smaller' from our log-likelihood. In other words, the log-likelihood dominates $g$ where \n\n\n$$\ng(\\mathbf{p}, \\theta | \\mathbf{p}_n, \\theta_n) = h \\ln \\theta + \\sum_i \\ln p_i - \\sum_i \\sum_j\n\\frac{(a_{ij} + b_{ij}) (\\theta p_i + p_j)}{\\theta_n p_{ni} + p_{nj}}\n$$\n\nwhere we've dropped the irrelevant constant.\n\n## Iterate\n\nNow we can optimize our surrogate $g$, instead of the objective function by setting the $\\nabla g = 0$. The $\\theta p_i$ term prevents direct optimization. Instead, we perform cyclic block ascent. That is, we update $\\theta$ holding $\\mathbf{p}$ fixed and we update each $p_i$ holding all other parameters fixed.\n\n. . .\n\nTo proceed, update\n\n\n$$\n\\theta_{n + 1} = \\frac{h}{\\sum_i \\sum_j \\frac{p_{ni}(a_{ij} + b_{ij})}{\\theta_n p_{ni} + p_{nj}}}\n$$\n\n\nand then update each\n\n\n$$\np_{n+1, i} = \\frac{w_i}{\n\\sum_j \\frac{\\theta_{n+1}(a_{ij} + b_{ij})}{\\theta_{n+1} p_{ni} + p_{nj}}\n+ \\sum_j \\frac{(a_{ji} + b_{ji})}{\\theta_{n+1} p_{nj} + p_{ni}}\n}.\n$$\n\n\n**Crucially** cyclic block ascent preserves the ascent property, that is, for objective function $f$, iterates $f(x_{n+1}) \\geq f(x_n)$ when $g$ minorizes $f$.\n\n\n. . . \n\n#### Check your understanding\n\n- Show the \"ascent\" property of the Minorize-Maximize algorithm algebraically.\n\n## Exercise\n\nTo be completed in the next lab... but we'll get started in class:\n\nImplement the MM algorithm as described on the previous slide for the NBA data. Your implementation should be able to be adapted to another data set of identical construction (i.e. don't hard-code values).\n\nWhat are the ten highest ranked teams (in order) from the 2015-2016 season according to the Bradley Terry model?\n\nIs there a home-field advantage? What are the odds of winning at home vs away?\n\n## Acknowledgements\n\nContent of this lecture based on chapter 1 of Dr. Ken Lange's *MM Optimization Algorithms*.\n\n> Lange, Kenneth. MM Optimization Algorithms. Society for Industrial and Applied Mathematics, 2016.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    function fireSlideChanged(previousSlide, currentSlide) {\n\n      // dispatch for htmlwidgets\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for reveal\n    if (window.Reveal) {\n      window.Reveal.addEventListener(\"slidechanged\", function(event) {\n        fireSlideChanged(event.previousSlide, event.currentSlide);\n      });\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}