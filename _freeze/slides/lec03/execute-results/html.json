{
  "hash": "65b301a3053db0cbff32abe23b3a76bc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"NAs, lists, NULL and attributes\"\nauthor: \"Dr. Alexander Fisher\"\nexecute:\n  warning: true\nformat: \n    revealjs:\n      smaller: true\n---\n\n\n\n# NAs (missing values)\n\n## Missing values\n\nR uses `NA` to represent missing values in its data structures.`NA` is a logical type. What may not be obvious is that `NA` may be treated as a different type thanks to coercion.\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(NA + 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(NA + 1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(c(NA, \"\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n::: fragment\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(NA_character_)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(NA_real_)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(NA_integer_)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(NA_complex_)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"complex\"\n```\n\n\n:::\n:::\n\n\n:::\n:::\n\n\\\n:::\n\n## `NA` stickiness\n\nBecause NAs represent missing values it makes sense that any calculation using them should also be missing.\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n1 / NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nNA * 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n3 ^ NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(c(1, 2, 3, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n:::\n:::\n\n. . .\n\nSummarizing functions (e.g. sum(), mean(), sd(), etc.) will often have a na.rm argument which will allow you to drop missing values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(c(1, 2, NA), na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(c(1, 2, NA), na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n## NAs are not always sticky\n\nA useful mental model for NAs is to consider them as a unknown value that could take any of the possible values for that type.\n\nFor numbers or characters this isn't very helpful, but for a logical value we know that the value must either be TRUE or FALSE and we can use that when deciding what value to return.\n\nIf the value of `NA` *affects* the logical outcome, it is indeterminate and the operation will return `NA`. If the value of `NA` *does not affect* the logical outcome, the operation will return the outcome.\n\n::: panel-tabset\n### Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE & NA\n\n\nFALSE & NA\n\n\nTRUE | NA\n\n\nFALSE | NA\n```\n:::\n\n\n\n### Output\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n:::\n\n## Testing for `NA`\n\nBecause `NA` could take any value, the result of, for example, `2 != NA` or `1 == NA` is inconclusive and returns `NA`.\n\n### Examples\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 != NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n1 == NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nWho's to say two missing values are equal?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA == NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nWe should instead:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n!is.na(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n## Other Special values (double)\n\nThese are defined as part of the IEEE floating point standard (not unique to R)\n\n-   `NaN` - Not a number\n-   `Inf` - Positive infinity\n-   `-Inf` - Negative infinity\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npi / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Inf\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n0 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n1 /0 + 1/0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Inf\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1/0 - 1/0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nNaN / NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nInf - Inf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n:::\n\n\n:::\n:::\n\n. . .\n\n::: callout-note\n**IEEE** (Institute of Electrical and Electronics Engineers) develops global standards for a broad range of industries including floating-point arithmetic. Read more about the IEEE 754 (the standard for floating-point arithmetic) [here](https://en.wikipedia.org/wiki/IEEE_754)\n:::\n\n## Testing for `Inf` and `NaN`\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.finite(Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.infinite(-Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.nan(Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nInf > 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n-Inf > 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.finite(NaN)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.infinite(NaN)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.nan(NaN)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.finite(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.nan(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n:::\n:::\n\n## Forced coercion\n\n::: columns\n::: {.column width=\"50%\"}\nYou can coerce one type to another with `as.()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.integer(2.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(\"2.0\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.integer(as.integer(2.0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.integer(Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n::: fragment\n`Inf` and `NaN` are doubles, however their coercion behavior is not the same as for other doubles.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.double(Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.double(NaN)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.integer(as.integer(Inf))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: NAs introduced by coercion to integer range\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.integer(as.integer(NaN))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n:::\n:::\n:::\n\n## Exercise 1\n\nWrite a function that takes vector input `x` and returns the smallest and largest non-infinite value. Test your function on \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, Inf, 100, 10, -Inf)\n```\n:::\n\n\n\n\n\n# Lists\n\n## Generic vectors (lists)\n\nTwo types of vectors in R. Atomic vectors (elements are all the same type) and generic vectors, aka **lists** (heterogeneous collection of elements). For example, a list can contain atomic vectors, functions, other lists, etc.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(\"A\", (1:4)/2, list(TRUE, 1), function(x) x^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"A\"\n\n[[2]]\n[1] 0.5 1.0 1.5 2.0\n\n[[3]]\n[[3]][[1]]\n[1] TRUE\n\n[[3]][[2]]\n[1] 1\n\n\n[[4]]\nfunction (x) \nx^2\n```\n\n\n:::\n:::\n\n\n\n## List structure\n\nWe can view the contents of a list and a brief description of the contents compactly with the structure function `str()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(list(\"A\", (1:4)/2, list(TRUE, 1), function(x) x^2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ : chr \"A\"\n $ : num [1:4] 0.5 1 1.5 2\n $ :List of 2\n  ..$ : logi TRUE\n  ..$ : num 1\n $ :function (x)  \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(1:100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:100] 1 2 3 4 5 6 7 8 9 10 ...\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(list(c(1,2), c(TRUE, FALSE)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ : num [1:2] 1 2\n $ : logi [1:2] TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n## Recursive lists\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(list(list(list(list())))) # recursive list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 1\n $ :List of 1\n  ..$ :List of 1\n  .. ..$ : list()\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(list(1, list(2), list(3, 2))) # recursive list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 3\n $ : num 1\n $ :List of 1\n  ..$ : num 2\n $ :List of 2\n  ..$ : num 3\n  ..$ : num 2\n```\n\n\n:::\n:::\n\n\n\nBecause of this, lists become the most natural way of representing tree-like structures within R\n\n## List coercion\n\nBy default a vector will be coerced to a list (as a list is more general) if needed\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr( c(1, list(4, list(6, 7))) )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 3\n $ : num 1\n $ : num 4\n $ :List of 2\n  ..$ : num 6\n  ..$ : num 7\n```\n\n\n:::\n:::\n\n\n\nWe can coerce a list into an atomic vector using `unlist` - the usual type coercion rules then apply to determine the final type.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist(list(1:3, list(4:5, 6)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5 6\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist( list(1, list(2, list(3, \"Hello\"))) )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"     \"2\"     \"3\"     \"Hello\"\n```\n\n\n:::\n:::\n\n\n\n`as.integer` and similar functions can be used, but only if the list is flat (i.e. no lists inside your base list)\n\n## Named lists\n\nBecause of their more complex structure we often want to name the elements of a list (we can also do this with atomic vectors).\n\nThis can make accessing list elements more straight forward.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(list(A = 1, B = list(C = 2, D = 3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ A: num 1\n $ B:List of 2\n  ..$ C: num 2\n  ..$ D: num 3\n```\n\n\n:::\n:::\n\n\n\nMore complex names need to be quoted,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(\"knock knock\" = \"who's there?\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`knock knock`\n[1] \"who's there?\"\n```\n\n\n:::\n:::\n\n\n\n## Exercise 2\n\nRepresent the following JSON (JavaScript Object Notation) data as a list in R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{\n  \"firstName\": \"John\",\n  \"lastName\": \"Smith\",\n  \"age\": 25,\n  \"address\": \n  {\n    \"streetAddress\": \"21 2nd Street\",\n    \"city\": \"New York\",\n    \"state\": \"NY\",\n    \"postalCode\": 10021\n  },\n  \"phoneNumber\": \n  [\n    {\n      \"type\": \"home\",\n      \"number\": \"212 555-1239\"\n    },\n    {\n      \"type\": \"fax\",\n      \"number\": \"646 555-4567\"\n    }\n  ]\n}\n```\n:::\n\n\n\n# `NULL` values\n\n## The `NULL` type\n\n`NULL` is a special value within R that represents nothing - it always has length zero and type \"NULL\" and cannot have any attributes.\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNULL\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NULL\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nc(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nc(1, NULL, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2\n```\n\n\n:::\n\n```{.r .cell-code}\nc(NULL, TRUE, \"A\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"TRUE\" \"A\"   \n```\n\n\n:::\n:::\n\n\n:::\n:::\n\nWhen combined in a vector, it disappears.\n\n## 0-length coercion\n\nPreviously we saw that in multi-vector operations, short vectors get re-used until the length of the long vector is matched.\n\n0-length length coercion is a special case of length coercion when one of the arguments has length 0. In this case the longer vector's length is not used and result will have length 0.\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninteger() + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnumeric(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(numeric())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnumeric(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nlogical() | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlogical(0)\n```\n\n\n:::\n\n```{.r .cell-code}\ncharacter() > \"M\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlogical(0)\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n::: fragment\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNULL + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnumeric(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(NULL)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in log(NULL): non-numeric argument to mathematical function\n```\n\n\n:::\n\n```{.r .cell-code}\nNULL | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlogical(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nNULL > \"M\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlogical(0)\n```\n\n\n:::\n:::\n\n\n:::\n:::\n:::\n\n::: fragment\nAs a NULL values always have length 0, this coercion rule will apply (note type coercion is also occurring here)\n:::\n\n## `NULL` and comparison\n\nGiven the previous issue, comparisons and conditional with `NULL`s can be problematic.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = NULL\n\nif (x > 0)\n  print(\"Hello\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in if (x > 0) print(\"Hello\"): argument is of length zero\n```\n\n\n:::\n\n```{.r .cell-code}\nif (!is.null(x) & (x > 0))\n  print(\"Hello\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in if (!is.null(x) & (x > 0)) print(\"Hello\"): argument is of length zero\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!is.null(x) && (x > 0))\n  print(\"Hello\")\n```\n:::\n\n\n\nThis is due to short circuit evaluation which occurs with `&&` and `||` but not `&` or `|`.\n\n# Attributes\n\n## Attributes\n\nAttributes are named lists that can be attached to objects in R. Attributes contain metadata about an object, e.g. the object's `names`, `dim`, `class`, `levels` etc.\n\n<!-- | Data structure | Built on              | Attribute(s)              | Quick creation               | -->\n<!-- |----------------|-----------------------|---------------------------|------------------------------| -->\n<!-- | Matrix, Array  | atomic vector         | `dim`                     | `matrix()`, `array()`        | -->\n<!-- | Factor         | atomic integer vector | `class, levels`           | `factor()`, `ordered()`      | -->\n<!-- | Date           | atomic double vector  | `class`                   | `as.Date()`                  | -->\n<!-- | Date-times     | atomic double vector  | `class`                   | `as.POSIXct()`, `as.POSIXlt` | -->\n<!-- | Data frame     | list                  | `class, names, row.names` | `data.frame()`               | -->\n\nAttributes can be interacted with via `attr` and `attributes` functions.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x = c(L=1,M=2,N=3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nL M N \n1 2 3 \n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"L\" \"M\" \"N\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(attributes(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 1\n $ names: chr [1:3] \"L\" \"M\" \"N\"\n```\n\n\n:::\n:::\n\n\n\n. . . \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(x, \"names\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"L\" \"M\" \"N\"\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(x, \"something\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n:::\n\n\n\n## Assigning attributes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 2, 3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(x) = c(\"Z\",\"Y\",\"X\") # helper function\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nZ Y X \n1 2 3 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Z\" \"Y\" \"X\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattr(x, \"names\") = c(\"A\",\"B\",\"C\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nA B C \n1 2 3 \n```\n\n\n:::\n\n```{.r .cell-code}\nnames(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A\" \"B\" \"C\"\n```\n\n\n:::\n:::\n\n\n\n## Factors\n\nFactor objects are how R represents categorical data (e.g. a variable where there are a fixed \\# of possible outcomes).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x = factor(c(\"Sunny\", \"Cloudy\", \"Rainy\", \"Cloudy\", \"Cloudy\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Sunny  Cloudy Rainy  Cloudy Cloudy\nLevels: Cloudy Rainy Sunny\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Factor w/ 3 levels \"Cloudy\",\"Rainy\",..: 3 1 2 1 1\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\nWhat's really going on?\n\n. . . \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$levels\n[1] \"Cloudy\" \"Rainy\"  \"Sunny\" \n\n$class\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\n\nA factor is just an integer vector with two attributes: `class` and `levels`.\n\n## Building objects\n\nWe can build our own factor from scratch using,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny = c(3L, 1L, 2L, 1L, 1L)\nattr(y, \"levels\") = c(\"Cloudy\", \"Rainy\", \"Sunny\")\nattr(y, \"class\") = \"factor\"\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Sunny  Cloudy Rainy  Cloudy Cloudy\nLevels: Cloudy Rainy Sunny\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nThe approach we just used is a bit clunky - generally the preferred method for construction an object with attributes from scratch is to use the structure function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny = structure(\n  c(3L, 1L, 2L, 1L, 1L), # data\n  levels = c(\"Cloudy\", \"Rainy\", \"Sunny\"),\n  class = \"factor\"\n)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Sunny  Cloudy Rainy  Cloudy Cloudy\nLevels: Cloudy Rainy Sunny\n```\n\n\n:::\n:::\n\n\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.factor(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n:::\n:::\n\n## Knowing factors are stored as integers help explain some of their more interesting behaviors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Sunny  Cloudy Rainy  Cloudy Cloudy\nLevels: Cloudy Rainy Sunny\n```\n\n\n:::\n\n```{.r .cell-code}\nx+1\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in Ops.factor(x, 1): '+' not meaningful for factors\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA NA NA NA NA\n```\n\n\n:::\n\n```{.r .cell-code}\nis.integer(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nas.integer(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 1 2 1 1\n```\n\n\n:::\n\n```{.r .cell-code}\nas.character(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Sunny\"  \"Cloudy\" \"Rainy\"  \"Cloudy\" \"Cloudy\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas.logical(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA NA NA NA NA\n```\n\n\n:::\n:::\n\n\n\n## Exercise 3\n\nCreate a factor vector based on the vector of airport codes below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nairports = c(\"RDU\", \"ABE\", \"DTW\", \"GRR\", \"RDU\", \"GRR\", \"GNV\",\n             \"JFK\", \"JFK\", \"SFO\", \"DTW\")\n```\n:::\n\n\n\nAll of the possible levels are\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"RDU\", \"ABE\", \"DTW\", \"GRR\", \"GNV\", \"JFK\", \"SFO\")\n```\n:::\n",
    "supporting": [
      "lec03_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}